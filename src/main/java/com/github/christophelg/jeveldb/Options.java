package com.github.christophelg.jeveldb;

import java.util.logging.Logger;

/**
 * From:
 * https://github.com/google/leveldb/blob/master/include/leveldb/options.h
 *
 * Options to control the behavior of a database (passed to DB::Open)
 * Created by Christophe on 27/12/2015.
 */
public class Options {
    // Parameters that affect behavior

    // Comparator used to define the order of keys in the table.
    // Default: a comparator that uses lexicographic byte-wise ordering
    //
    // REQUIRES: The client must ensure that the comparator supplied
    // here has the same name and orders keys *exactly* the same as the
    // comparator provided to previous open calls on the same DB.
    private Comp comparator;

    // If true, the database will be created if it is missing.
    // Default: false
    private boolean createIfMissing;

    // If true, an error is raised if the database already exists.
    // Default: false
    private boolean errorIfExists;

    // If true, the implementation will do aggressive checking of the
    // data it is processing and will stop early if it detects any
    // errors.  This may have unforeseen ramifications: for example, a
    // corruption of one DB entry may cause a large number of entries to
    // become unreadable or for the entire DB to become unopenable.
    // Default: false
    private boolean paranoidChecks;

    // Any internal progress/error information generated by the db will
    // be written to info_log if it is non-NULL, or to a file stored
    // in the same directory as the DB contents if info_log is NULL.
    // Default: NULL
    private Logger logger;

    // -------------------
    // Parameters that affect performance

    // Amount of data to build up in memory (backed by an unsorted log
    // on disk) before converting to a sorted on-disk file.
    //
    // Larger values increase performance, especially during bulk loads.
    // Up to two write buffers may be held in memory at the same time,
    // so you may wish to adjust this parameter to control memory usage.
    // Also, a larger write buffer will result in a longer recovery time
    // the next time the database is opened.
    //
    // Default: 4MB
    private int writeBufferSize = 4 * 1024 * 1024;

    // Number of open files that can be used by the DB.  You may need to
    // increase this if your database has a large working set (budget
    // one open file per 2MB of working set).
    //
    // Default: 1000
    private int maxOpenFiles = 1000;

    // Control over blocks (user data is stored in a set of blocks, and
    // a block is the unit of reading from disk).

    // If non-NULL, use the specified cache for blocks.
    // If NULL, leveldb will automatically create and use an 8MB internal cache.
    // Default: NULL
    private Cache blockCache;

    // Approximate size of user data packed per block.  Note that the
    // block size specified here corresponds to uncompressed data.  The
    // actual size of the unit read from disk may be smaller if
    // compression is enabled.  This parameter can be changed dynamically.
    //
    // Default: 4K
    private int blockSize = 4 * 1024;

    // Number of keys between restart points for delta encoding of keys.
    // This parameter can be changed dynamically.  Most clients should
    // leave this parameter alone.
    //
    // Default: 16
    private int blockRestartInterval=16;

    // Compress blocks using the specified compression algorithm.  This
    // parameter can be changed dynamically.
    //
    // Default: kSnappyCompression, which gives lightweight but fast
    // compression.
    //
    // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
    //    ~200-500MB/s compression
    //    ~400-800MB/s decompression
    // Note that these speeds are significantly faster than most
    // persistent storage speeds, and therefore it is typically never
    // worth switching to kNoCompression.  Even if the input data is
    // incompressible, the kSnappyCompression implementation will
    // efficiently detect that and will switch to uncompressed mode.
    private CompressionType compression = CompressionType.SNAPPY;

    // EXPERIMENTAL: If true, append to existing MANIFEST and log files
    // when a database is opened.  This can significantly speed up open.
    //
    // Default: currently false, but may become true later.
    private boolean reuseLogs;

    // If non-NULL, use the specified filter policy to reduce disk reads.
    // Many applications will benefit from passing the result of
    // NewBloomFilterPolicy() here.
    //
    // Default: NULL
    private FilterPolicy filterPolicy;

    public Comp getComparator() {
        return comparator;
    }

    public void setComparator(Comp comparator) {
        this.comparator = comparator;
    }

    public boolean isCreateIfMissing() {
        return createIfMissing;
    }

    public void setCreateIfMissing(boolean createIfMissing) {
        this.createIfMissing = createIfMissing;
    }

    public boolean isErrorIfExists() {
        return errorIfExists;
    }

    public void setErrorIfExists(boolean errorIfExists) {
        this.errorIfExists = errorIfExists;
    }

    public boolean isParanoidChecks() {
        return paranoidChecks;
    }

    public void setParanoidChecks(boolean paranoidChecks) {
        this.paranoidChecks = paranoidChecks;
    }

    public Logger getLogger() {
        return logger;
    }

    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    public int getWriteBufferSize() {
        return writeBufferSize;
    }

    public void setWriteBufferSize(int writeBufferSize) {
        this.writeBufferSize = writeBufferSize;
    }

    public int getMaxOpenFiles() {
        return maxOpenFiles;
    }

    public void setMaxOpenFiles(int maxOpenFiles) {
        this.maxOpenFiles = maxOpenFiles;
    }

    public Cache getBlockCache() {
        return blockCache;
    }

    public void setBlockCache(Cache blockCache) {
        this.blockCache = blockCache;
    }

    public int getBlockSize() {
        return blockSize;
    }

    public void setBlockSize(int blockSize) {
        this.blockSize = blockSize;
    }

    public int getBlockRestartInterval() {
        return blockRestartInterval;
    }

    public void setBlockRestartInterval(int blockRestartInterval) {
        this.blockRestartInterval = blockRestartInterval;
    }

    public CompressionType getCompression() {
        return compression;
    }

    public void setCompression(CompressionType compression) {
        this.compression = compression;
    }

    public boolean isReuseLogs() {
        return reuseLogs;
    }

    public void setReuseLogs(boolean reuseLogs) {
        this.reuseLogs = reuseLogs;
    }

    public FilterPolicy getFilterPolicy() {
        return filterPolicy;
    }

    public void setFilterPolicy(FilterPolicy filterPolicy) {
        this.filterPolicy = filterPolicy;
    }
}
